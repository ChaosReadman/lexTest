# lex and yacc programming  
lex & Yacc プログラミングのコードをUbuntu20.04LTSで動くように修正したもの  
https://iss.ndl.go.jp/books/R100000002-I000002412297-00  

Cの書き方が古すぎて、コードの品質も納得できない所が多い。  
そもそも動かないところもあるので、  
元のコードをあまり直さないまま、動くようにしている。  

ただ、４章のメニュー作成言語や５章の意味不明なSQLのパースとか、  
やる意味が見いだせないので３章までにしておく  
６章以降は、各lex処理系などの説明や、  
一度出したコーディングの再掲みたいなものなので、  
全くこの本、クソとしかいいようがない。  
なんの説明もなく、lexやyaccのコードから始めているので、  
本の６章以降の説明と被るが、なぜそんな後半に説明をしているんだろうか？  
順番が違うと思うので以下に説明をする。  

ubuntu20.04.LTSでは以下の様にリンクが貼られている。  

/usr/bin/lex -> flex  
/usr/bin/yacc -> /etc/alternatives/yacc  
/etc/alternatives/yacc -> /usr/bin/bison.yacc  
となっており、中身はシェルスクリプトでyacc流に合わせてbisonを動かしている。  
  
lexとyaccは何者かというと、  
lexは字句解析をする。  
yaccは構文解析をする。  
  
lexのゴールは、yylex()というCの関数をつくることだ。  
この関数は引数無しで呼び出し、ファイルの終わりで0を返す。 
yylex()は、字句解析をしてトークンに分解し、そのトークンの種類に応じた値を返す。  
  
この時、yytextという名前の文字列を外部データように作成する。  
yytextはyyinから字句解析して読み取れたトークン文字列が入っている。  
  
また同時に、yylengにはyytextの文字数が入っている。  
yacc側に渡すために、yylval というオブジェクトを使う。  
yylex()が整数トークンを読んだとき、yytextには整数の文字列が入るが、  
yylvalには実際に数値をいれることで、yacc側に渡すのが通例となっている。  
  
yaccのゴールは、yyparse()というCの関数をつくることで、  
yyparse()はlexの出力するyylex()を呼び出すようになっている。  
したがって、C側からyyparse()を呼び出すと、yylex()も呼び出され、  
yyparse()されていくのだが、順次処理を繰り返すかどうかについては、  
yywrap()の戻り値で決定する作りになっている。  
